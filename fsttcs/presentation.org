#+TITLE:     Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks
#+AUTHOR:    *Aniket Mishra (IIT Gandhinagar)*, Abhishek Bichhawat (IIT Gandhinagar)
#+EMAIL:     aniket.mishra@iitgn.ac.in, abhishek.b@iitgn.ac.in
#+DATE:      [2025-12-18 Thu]
#+DESCRIPTION: Example of using org to create presentations using the beamer exporter
#+KEYWORDS:  beamer org orgmode
#+LANGUAGE:  en
#+STARTUP: beamer
#+STARTUP: oddeven
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Antibes
#+OPTIONS:   H:2 toc:t
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+COLUMNS: %20ITEM %13BEAMER_ENV(Env) %6BEAMER_ENVARGS(Args) %4BEAMER_COL(Col) %7BEAMER_EXTRA(Extra)

* Timing-Based Side Channel Leaks  
** Traditional Cybersecurity
   Traditionally, cybersecurity has dealt with the analysis of *overt* channels.
    #+ATTR_LATEX: width=\textwidth
    [[file:./alice_bob.jpg]]
** What are Side Channels?
   A /side/ channel, on the other hand, involves no such direct access. Instead, vulnerabilities are introduced by *side effects* of a program's execution.
   \pause
   + Power used during the program's execution
   \pause
   + Sound generated by the machine running the program
   \pause
   + *Time it takes for the program to execute*
** An Illustrative Example
   Let us consider a C program that checks some input against a given password by comparing it by character by character.
   #+begin_src C :eval never
   bool matchpwd ( int * input , size_t n ) {
     if ( n != pwd_length ) return false;
     for ( int i = 0; i < n ; i ++) {
       if ( input [ i ] != pwd [ i ]) return false ;
     }
     return true ;
   }
   #+end_src
** An Exploit
   Let's say the password is *101010*, an exploit may look like the following.
*** An Attack Trace                                                  :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
   
    000000 \dotfill Rejected in 1^{st} iteration \pause \\
    \alert{10}0000 \dotfill Rejected in 3^{rd} iteration \pause \\
    \alert{1}10000 \dotfill Rejected in 2^{nd} iteration \pause \\
    \alert{1010}00 \dotfill Rejected in 5^{th} iteration \pause \\
    \alert{101}100 \dotfill Rejected in 4^{th} iteration \pause \\
    *101010* \dotfill Password accepted!
** The Reality of Timing Side Channels
   Speculative execution and cache side channels are subtler ways that these vulnerabilities can be introduced.
   [[file:spooky.png]]
   
* Mitigating Timing-Based Side Channel Leaks
** Dummy Code Insertion
   [[file:./agat.png]]
   From Transforming Timing Leaks by Johan Agat
** Constant Time Programming
*** Constant Time Program       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
   #+begin_src C
   bool equals(byte a[], size_t a_len,
   	    byte b[], size_t b_len) {
     volatile size_t x = a_len ^ b_len;
     for (size_t i = 0;
          ((i < a_len) & (i < b_len));
          i++) {x |= a[i] ^ b[i]; }
     return (x==0); }
   #+end_src
*** Preservation of Constant Time Property       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Separately, work has been done on ensuring the preservation of this invariant.
    See: Formal verification of a constant-time preserving C compiler by Barthe et. al.   
** Code Generation
*** Program Repair                                                     :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Work has been done in linearising the source code of a program.
    
    See: Eliminating Timing Side-Channel Leaks using Program Repair by Wu et al.
*** Transforming IR                                                    :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Similarly, work has also been done at generating constant time code given a non constant-time program.

    See: Constantine: Automatic Side-Channel Resistance Using Efficient Control and Data Flow Linearization by Borrello et al.
** Our Approach
   + All of the above approaches require the entire *source code* to be available beforehand. This is *not always possible*.\pause
   + Many of these approaches employ the use of testing and fuzzing-based techniques to find sensitive execution pathways in the program. \pause
   + Thus, we propose a *runtime semantics* that takes care by expanding on techniques used in *dynamic Information Flow Control*. \pause Furthermore, we *prove* that our semantics has the desired properties within the *Rocq theorem prover*.
* Fall-Through Semantics for Mitigating Timing-Based Side Channel leaks
** The WHILE Language
   $\mu := \cdot ~\arrowvert ~ \mu, x \Rightarrow n^k$

   \pause
   
   $e := n ~\arrowvert ~x ~\arrowvert ~ e_1 \oplus ~e_2$

   \pause

   $c := \textsf{skip} ~\arrowvert ~x:=e  ~\arrowvert ~c_1;c_2 ~\arrowvert ~\textsf{if} ~e ~\textsf{then} ~c_1 ~\textsf{else} ~c_2 ~\arrowvert ~\textsf{while} ~e ~\textsf{do} ~c$
   
** Judgements
*** Expression Judgement                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    \[e ~\arrowvert ~\mu \Downarrow_{pc} T, n^{k} \]

    An expression given some store /\mu/ and some evaluation level /pc/, evaluates to some primitive value /n/ along with some label /k/, within time /T/.
*** Command Judgement(s)                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_act: <2->
    :END:

    \[c ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu'  ~ ~ ~ ~ ~ \textsf{debranch}(c, n, \ell) ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu' \]

    A command given some store /mu/, and evaluation level /pc/ produces a store /\mu'/ in time /T/.
** Dynamic IFC
   Let us imagine there are variables /x/ and /y/, where /x/ is hidden and holds some sensitive data and /y/ does not. There are 3 kinds of leaks that could happen. \pause
*** Direct Flow                                                      :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
    \(y:=x\)
    \pause
*** Indirect Flow                                                    :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
    \(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~y:=1 \)
    \pause
*** Side Channel                                                     :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
    \(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~\{y:=1; ~y:=1\} \)
    
** Threat Model
   Thus, given an adversary that can execute the program under security label \ell. \pause
*** Data Security       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    The adversary can view the state of the memory, but values that are high relative to \ell are invisible. \pause
    As an example, let us take \(L \sqsubseteq M \sqsubseteq H\) and let us take \(\ell = M\).

    Let us say our /\mu/ is /x \rightarrow true^{L}, y \rightarrow true^{M}, z \rightarrow true^{H}/, then the adversary's view of the memory is: \pause

    /x \rightarrow true^{L}, y \rightarrow true^{M}, z \rightarrow */
    \pause
*** Timing Security       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    The adversary has exact knowledge of when and where each memory access takes place during a program's execution.
** Expression Semantics
   [[file:./expr.png]]
** Command Semantics
*** The Basics       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    [[file:./basics_c.png]]
    \pause
*** IF-HIGH       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    [[file:./ifhigh_c.png]]
** Debranch Semantics: The Basics
    [[file:./basics_d.png]] 
** Debranch Semantics: IFs
   [[file:./ifs.png]]
* (Formal) Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks
** Rocq, Rocq, Correct!
   We choose to prove our theorems and formalise our semantics within the *Rocq* (formerly Coq) theorem prover.
** PartialOrder
    #+ATTR_LATEX: width=\textwidth
   [[file:./partial_order.png]]
** Join Semi-Lattice
   [[file:./join.png]]
** Expressing Grammars
   [[file:./grammar.png]]
** Expressing Semantics
   [[file:./semantics.png]]
** Observational Equivalence
   [[file:./obseq.png]]

*** Observational Equivalence     :B_theorem:
    :PROPERTIES:
    :BEAMER_env: theorem
    :END:
    For any given /c, \mu_{1}, \mu_{2}/ and /pc/
    \[\mu_{1} \sim_\ell \mu_{2} \rightarrow \mu'_{1} \sim_{\ell}\mu'_{2} \]

    where
    \(c ~\arrowvert ~\mu_{1} \Downarrow_{pc} T_{1} ~\arrowvert ~\mu'_{1}\) and
    \(c ~\arrowvert ~\mu_{2} \Downarrow_{pc} T_{2} ~\arrowvert ~\mu'_{2}\)
** Timing Sensitive Non-Interference
   [[file:./timsec.png]]
*** Timing Sensitive Non-Interference                                :B_theorem:
    :PROPERTIES:
    :BEAMER_env: theorem
    :END:
    For any given /c, \mu_{1}, \mu_{2}/ and /pc/
    \[\mu_{1} \sim_\ell \mu_{2} \rightarrow T_{1} = T_{2}\]

    where
    \(c ~\arrowvert ~\mu_{1} \Downarrow_{pc} T_{1} ~\arrowvert ~\mu'_{1}\) and
    \(c ~\arrowvert ~\mu_{2} \Downarrow_{pc} T_{2} ~\arrowvert ~\mu'_{2}\)

** Soundness
    [[file:./sound.png]]
*** Timing Soundness                                                 :B_theorem:
    :PROPERTIES:
    :BEAMER_env: theorem
    :END:
    For any given /c, \mu/ and /pc/
    
    \[c ~\arrowvert ~\mu_{} \Downarrow_{pc} T ~\arrowvert ~\mu' \rightarrow c ~\arrowvert ~\mu_{\downarrow} \Downarrow \mu'_{\downarrow} \]

    
** Partial Completeness
   [[file:./pcomplete.png]]

*** Partial Completeness                                             :B_theorem:
    :PROPERTIES:
    :BEAMER_env: theorem
    :END:
    For any given /c, \mu/ and /pc/ such that /c/ contains no "while" commands, if for some /\eta/ we have \(c ~\arrowvert ~\mu \Downarrow \eta \),
    there exist /T/ and /mu'/ for which we have
    \[c ~\arrowvert ~\mu_{} \Downarrow_{pc} T ~\arrowvert ~\mu' ~\land ~  \mu'_{\downarrow} = \eta \]
** Concluding
   That's all! Thanks for attending my talk. If you wish to contact me you can do so at [[mailto:aniket.mishra@iitgn.ac.in]].
