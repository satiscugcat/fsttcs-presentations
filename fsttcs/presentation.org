#+TITLE:     Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks
#+AUTHOR:    Aniket Mishra, Abhishek Bichhawat
#+EMAIL:     aniket.mishra@iitgn.ac.in, abhishek.b@iitgn.ac.in
#+DATE:      [2025-12-18 Thu]
#+DESCRIPTION: Example of using org to create presentations using the beamer exporter
#+KEYWORDS:  beamer org orgmode
#+LANGUAGE:  en
#+STARTUP: beamer
#+STARTUP: oddeven
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Madrid
#+OPTIONS:   H:2 toc:t
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+COLUMNS: %20ITEM %13BEAMER_ENV(Env) %6BEAMER_ENVARGS(Args) %4BEAMER_COL(Col) %7BEAMER_EXTRA(Extra)

* Timing-Based Side Channel Leaks  
** Traditional Cybersecurity
   Traditionally, cybersecurity has dealt with the analysis of *overt* channels.
    #+ATTR_LATEX: width=\textwidth
    [[file:./alice_bob.jpg]]
** What are Side Channels?
   A /side/ channel, on the other hand, involves no such direct access. Instead, vulnerabilities are introduced by *side effects* of a program's execution.
   \pause
   + Power used during the program's execution
   \pause
   + Sound generated by the machine running the program
   \pause
   + *Time it takes for the program to execute*
** An Illustrative Example
   Let us consider a C program that checks some input against a given password by comparing it by character by character.
   #+begin_src C :eval never
   bool matchpwd ( int * input , size_t n ) {
     if ( n != pwd_length ) return false;
     for ( int i = 0; i < n ; i ++) {
       if ( input [ i ] != pwd [ i ]) return false ;
     }
     return true ;
   }
   #+end_src
** An Exploit
   Let's say the password is *101010*, an exploit may look like the following.
*** An Attack Trace                                                  :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
   
    000000 \dotfill Rejected in 1^{st} iteration \pause \\
    \alert{10}0000 \dotfill Rejected in 3^{rd} iteration \pause \\
    \alert{1}10000 \dotfill Rejected in 2^{nd} iteration \pause \\
    \alert{1010}00 \dotfill Rejected in 5^{th} iteration \pause \\
    \alert{101}100 \dotfill Rejected in 4^{th} iteration \pause \\
    *101010* \dotfill Password accepted!
** The Reality of Timing Side Channels
   Speculative execution and cache side channels are subtler ways that these vulnerabilities can be introduced.
   [[file:spooky.png]]
   
* Mitigating Timing-Based Side Channel Leaks
** Dummy Code Insertion
   [[file:./agat.png]]
** Constant Time Programming
*** Constant Time Program       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
   #+begin_src C
   bool equals(byte a[], size_t a_len, byte b[], size_t b_len) {
     volatile size_t x = a_len ^ b_len;
     for (size_t i = 0; ((i < a_len) & (i < b_len)); i++) {
       x |= a[i] ^ b[i];
     }
     return (x==0);
   }
   #+end_src
*** Preservation of Constant Time Property       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Separately, work has been done on ensuring the preservation of this invariant.
    See: Formal verification of a constant-time preserving C compiler by Barthe et. al.   
** Code Generation
*** Program Repair                                                     :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Work has been done in linearising the source code of a program.
    
    See: Eliminating Timing Side-Channel Leaks using Program Repair by Wu et al.
*** Transforming IR                                                    :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Similarly, work has also been done at generating constant time code given a non constant-time program.

    See: Constantine: Automatic Side-Channel Resistance Using Efficient Control and Data Flow Linearization by Borrello et al.
** Our Approach
   All of the above approaches require the entire *source code* to be available beforehand. This is not necessarily true in applications such as the Web, where code may be available only *during execution*. Furthermore, many of these approaches employ the use of testing and fuzzing-based techniques to find sensitive execution pathways in the program, thus not providing *guarantees* on the code being side-channel free. \pause Thus, we propose a *runtime semantics* that takes care by expanding on techniques used in *dynamic Information Flow Control*. Furthermore, we *prove* that our semantics has the desired properties within the *Rocq theorem prover*.
* Fall-Through Semantics for Mitigating Timing-Based Side Channel leaks
** The WHILE Language
   $\mu := \cdot ~\arrowvert ~ \mu, x \Rightarrow n^k$

   \pause
   
   $e := n ~\arrowvert ~x ~\arrowvert ~ e_1 \oplus ~e_2$

   \pause

   $c := \textsf{skip} ~\arrowvert ~x:=e  ~\arrowvert ~c_1;c_2 ~\arrowvert ~\textsf{if} ~e ~\textsf{then} ~c_1 ~\textsf{else} ~c_2 ~\arrowvert ~\textsf{while} ~e ~\textsf{do} ~c$
   
** Judgements
*** Expression Judgement                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    \[e ~\arrowvert ~\mu \Downarrow_{pc} T, n^{k} \]

    An expression given some store /\mu/ and some evaluation level /pc/, evaluates to some primitive value /n/ along with some label /k/, within time /T/.
*** Command Judgement(s)                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_act: <2->
    :END:

    \[c ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu'  ~ ~ ~ ~ ~ \textsf{debranch}(c, n, \ell) ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu' \]

    A command given some store /mu/, and evaluation level /pc/ produces a store /\mu'/ in time /T/.
** Dynamic IFC
   Let us imagine there are variables /x/ and /y/, where /x/ holds some sensitive data and /y/ does not. There are 3 kinds of leaks that could happen. \pause
*** Direct Flow                                                      :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
    \(x:=y\)
    \pause
*** Indirect Flow                                                    :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
    \(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~y:=1 \)
    \pause
*** Side Channel                                                     :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
    \(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~\{y:=1; ~y:=1\} \)
    
** Threat Model
   Thus, given an adversary that can execute the program under security label \ell. \pause
*** Data Security       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    The adversary can view the state of the memory, but values that are high relative to \ell are invisible. \pause
    As an example, let us take \(L \sqsubseteq M \sqsubseteq H\) and let us take \(\ell = M\).

    Let us say our /\mu/ is /x \rightarrow true^{L}, y \rightarrow true^{M}, z \rightarrow true^{H}/, then the adversary's view of the memory is: \pause

    /x \rightarrow true^{L}, y \rightarrow true^{M}, z \rightarrow */
    \pause
*** Timing Security       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    The adversary has exact knowledge of when and where each memory access takes place during a program's execution.
** Expression Semantics
   [[file:./expr.png]]
** Command Semantics
*** The Basics       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    [[file:./basics_c.png]]
    \pause
*** IF-HIGH       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    [[file:./ifhigh_c.png]]
** Debranch Semantics: The Basics
    [[file:./basics_d.png]] 
** Debranch Semantics: IFs
    [[file:./ifs.png]]
* (Formal) Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks
** Rocq, Rocq, Correct!
   We choose to prove our theorems and formalise our semantics within the *Rocq* (formerly Coq) theorem prover.
** PartialOrder
    #+ATTR_LATEX: width=\textwidth
   [[file:./partial_order.png]]
** Join Semi-Lattice
   [[file:./join.png]]
** Observational Equivalence
** Timing Sensitive Non-Interference
** Threat Model, Revisited
