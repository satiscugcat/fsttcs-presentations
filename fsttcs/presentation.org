#+TITLE:     Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks
#+AUTHOR:    Aniket Mishra, Abhishek Bichhawat
#+EMAIL:     aniket.mishra@iitgn.ac.in, abhishek.b@iitgn.ac.in
#+DATE:      [2025-12-18 Thu]
#+DESCRIPTION: Example of using org to create presentations using the beamer exporter
#+KEYWORDS:  beamer org orgmode
#+LANGUAGE:  en
#+STARTUP: beamer
#+STARTUP: oddeven
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: Madrid
#+OPTIONS:   H:2 toc:t
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+COLUMNS: %20ITEM %13BEAMER_ENV(Env) %6BEAMER_ENVARGS(Args) %4BEAMER_COL(Col) %7BEAMER_EXTRA(Extra)

* Timing-Based Side Channel Leaks  
** Traditional Cybersecurity
   Traditionally, cybersecurity has dealt with the analysis of *overt* channels.
    #+ATTR_LATEX: width=\textwidth
    [[file:./alice_bob.jpg]]
** What are Side Channels?
   A /side/ channel, on the other hand, involves no such direct access. Instead, vulnerabilities are introduced by *side effects* of a program's execution.
   \pause
   + Power used during the program's execution
   \pause
   + Sound generated by the machine running the program
   \pause
   + *Time it takes for the program to execute*
** An Illustrative Example
   Let us consider a C program that checks some input against a given password by comparing it by character by character.
   #+begin_src C :eval never
   bool matchpwd ( int * input , size_t n ) {
     if ( n != pwd_length ) return false;
     for ( int i = 0; i < n ; i ++) {
       if ( input [ i ] != pwd [ i ]) return false ;
     }
     return true ;
   }
   #+end_src
** An Exploit
   Let's say the password is *101010*, an exploit may look like the following.
*** An Attack Trace                                                  :B_example:
    :PROPERTIES:
    :BEAMER_env: example
    :END:
   
    000000 \dotfill Rejected in 1^{st} iteration \pause \\
    \alert{10}0000 \dotfill Rejected in 3^{rd} iteration \pause \\
    \alert{1}10000 \dotfill Rejected in 2^{nd} iteration \pause \\
    \alert{1010}00 \dotfill Rejected in 5^{th} iteration \pause \\
    \alert{101}100 \dotfill Rejected in 4^{th} iteration \pause \\
    *101010* \dotfill Password accepted!
** The Reality of Timing Side Channels
   Speculative execution and cache side channels are subtler ways that these vulnerabilities can be introduced.
   [[file:spooky.png]]
   
* Mitigating Timing-Based Side Channel Leaks
** Dummy Code Insertion
   [[file:./agat.png]]
** Constant Time Programming
*** Constant Time Program       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
   #+begin_src C
   bool equals(byte a[], size_t a_len, byte b[], size_t b_len) {
     volatile size_t x = a_len ^ b_len;
     for (size_t i = 0; ((i < a_len) & (i < b_len)); i++) {
       x |= a[i] ^ b[i];
     }
     return (x==0);
   }
   #+end_src
*** Preservation of Constant Time Property       :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Separately, work has been done on ensuring the preservation of this invariant.
    See: Formal verification of a constant-time preserving C compiler by Barthe et. al.   
** Code Generation
*** Program Repair                                                     :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Work has been done in linearising the source code of a program.
    
    See: Eliminating Timing Side-Channel Leaks using Program Repair by Wu et al.
*** Transforming IR                                                    :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    Similarly, work has also been done at generating constant time code given a non constant-time program.

    See: Constantine: Automatic Side-Channel Resistance Using Efficient Control and Data Flow Linearization by Borrello et al.
** Our Approach

   All of the above approaches require the entire source code to be available beforehand. This is not necessarily true in applications such as the Web, where code is available at run-time. Furthermore, many of these approaches employ the use of testing and fuzzing-based techniques to find sensitive execution pathways in the program, thus not providing guarantees on code being side-channel free. Thus, we propose a runtime semantics that takes care by expanding on techniques used in dynamic Information Flow Control.
* Fall-Through Semantics for Mitigating Timing-Based Side Channel leaks
** The WHILE Language
   [[file:./WHILE.png]]
** Further Notation
** Judgements
*** Expression Judgement                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :END:
    \[e ~\arrowvert ~\mu \Downarrow_{pc} T, n^{k} \]

*** Command Judgement(s)                                               :B_block:
    :PROPERTIES:
    :BEAMER_env: block
    :BEAMER_act: <2->
    :END:

    \[c ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu'  ~ ~ ~ ~ ~ \textsf{debranch}(c, n, \ell) ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu' \]
    
** Explicit and Implicit Flow
** Threat Model
** Expression Semantics
** Command Semantics
** Debranch Semantics
* (Formal) Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks
** Rocq, Rocq, Correct!
** Threat Model, Revisited
** Join Semi-lattice
** Observational Equivalence
** Timing Sensitive Non-Interference
