% Created 2025-12-15 Mon 14:40
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usetheme{Madrid}
\author{Aniket Mishra, Abhishek Bichhawat}
\date{\textit{{[}2025-12-18 Thu]}}
\title{Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks}
\hypersetup{
 pdfauthor={Aniket Mishra, Abhishek Bichhawat},
 pdftitle={Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks},
 pdfkeywords={beamer org orgmode},
 pdfsubject={Example of using org to create presentations using the beamer exporter},
 pdfcreator={Emacs 30.2 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Timing-Based Side Channel Leaks}
\label{sec:org65c67d9}
\begin{frame}[label={sec:org202d280}]{Traditional Cybersecurity}
Traditionally, cybersecurity has dealt with the analysis of \alert{overt} channels.
\begin{center}
\includegraphics[width=.9\linewidth]{./alice_bob.jpg}
\end{center}
\end{frame}
\begin{frame}[label={sec:org97b6b31}]{What are Side Channels?}
A \emph{side} channel, on the other hand, involves no such direct access. Instead, vulnerabilities are introduced by \alert{side effects} of a program's execution.
\pause
\begin{itemize}
\item Power used during the program's execution
\end{itemize}
\pause
\begin{itemize}
\item Sound generated by the machine running the program
\end{itemize}
\pause
\begin{itemize}
\item \alert{Time it takes for the program to execute}
\end{itemize}
\end{frame}
\begin{frame}[label={sec:orgfa2d4df},fragile]{An Illustrative Example}
 Let us consider a C program that checks some input against a given password by comparing it by character by character.
\begin{verbatim}
bool matchpwd ( int * input , size_t n ) {
  if ( n != pwd_length ) return false;
  for ( int i = 0; i < n ; i ++) {
    if ( input [ i ] != pwd [ i ]) return false ;
  }
  return true ;
}
\end{verbatim}
\end{frame}
\begin{frame}[label={sec:org1a4d294}]{An Exploit}
Let's say the password is \alert{101010}, an exploit may look like the following.
\begin{example}[An Attack Trace]\label{sec:org2de9a63}
000000 \dotfill Rejected in 1\textsuperscript{st} iteration \pause \\
\alert{10}0000 \dotfill Rejected in 3\textsuperscript{rd} iteration \pause \\
\alert{1}10000 \dotfill Rejected in 2\textsuperscript{nd} iteration \pause \\
\alert{1010}00 \dotfill Rejected in 5\textsuperscript{th} iteration \pause \\
\alert{101}100 \dotfill Rejected in 4\textsuperscript{th} iteration \pause \\
\alert{101010} \dotfill Password accepted!
\end{example}
\end{frame}
\begin{frame}[label={sec:orgc51790a}]{The Reality of Timing Side Channels}
Speculative execution and cache side channels are subtler ways that these vulnerabilities can be introduced.
\begin{center}
\includegraphics[width=.9\linewidth]{spooky.png}
\end{center}
\end{frame}
\section{Mitigating Timing-Based Side Channel Leaks}
\label{sec:orga97e23a}
\begin{frame}[label={sec:orgbeee162}]{Dummy Code Insertion}
\begin{center}
\includegraphics[width=.9\linewidth]{./agat.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:org00f7430},fragile]{Constant Time Programming}
 \begin{block}{Constant Time Program}
\begin{verbatim}
bool equals(byte a[], size_t a_len, byte b[], size_t b_len) {
  volatile size_t x = a_len ^ b_len;
  for (size_t i = 0; ((i < a_len) & (i < b_len)); i++) {
    x |= a[i] ^ b[i];
  }
  return (x==0);
}
\end{verbatim}
\end{block}
\begin{block}{Preservation of Constant Time Property}
Separately, work has been done on ensuring the preservation of this invariant.
See: Formal verification of a constant-time preserving C compiler by Barthe et. al.   
\end{block}
\end{frame}
\begin{frame}[label={sec:org561f53b}]{Code Generation}
\begin{block}{Program Repair}
Work has been done in linearising the source code of a program.

See: Eliminating Timing Side-Channel Leaks using Program Repair by Wu et al.
\end{block}
\begin{block}{Transforming IR}
Similarly, work has also been done at generating constant time code given a non constant-time program.

See: Constantine: Automatic Side-Channel Resistance Using Efficient Control and Data Flow Linearization by Borrello et al.
\end{block}
\end{frame}
\begin{frame}[label={sec:orgd7d9753}]{Our Approach}
All of the above approaches require the entire \alert{source code} to be available beforehand. This is not necessarily true in applications such as the Web, where code may be available only \alert{during execution}. Furthermore, many of these approaches employ the use of testing and fuzzing-based techniques to find sensitive execution pathways in the program, thus not providing \alert{guarantees} on the code being side-channel free. \pause Thus, we propose a \alert{runtime semantics} that takes care by expanding on techniques used in \alert{dynamic Information Flow Control}. Furthermore, we \alert{prove} that our semantics has the desired properties within the \alert{Rocq theorem prover}.
\end{frame}
\section{Fall-Through Semantics for Mitigating Timing-Based Side Channel leaks}
\label{sec:org4ec2b75}
\begin{frame}[label={sec:org35870a0}]{The WHILE Language}
\(\mu := \cdot ~\arrowvert ~ \mu, x \Rightarrow n^k\)

\pause

\(e := n ~\arrowvert ~x ~\arrowvert ~ e_1 \oplus ~e_2\)

\pause

\(c := \textsf{skip} ~\arrowvert ~x:=e  ~\arrowvert ~c_1;c_2 ~\arrowvert ~\textsf{if} ~e ~\textsf{then} ~c_1 ~\textsf{else} ~c_2 ~\arrowvert ~\textsf{while} ~e ~\textsf{do} ~c\)
\end{frame}
\begin{frame}[label={sec:org8e61acf}]{Judgements}
\begin{block}{Expression Judgement}
\[e ~\arrowvert ~\mu \Downarrow_{pc} T, n^{k} \]

An expression given some store \emph{\(\mu\)} and some evaluation level \emph{pc}, evaluates to some primitive value \emph{n} along with some label \emph{k}, within time \emph{T}.
\end{block}
\begin{block}<2->{Command Judgement(s)}
\[c ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu'  ~ ~ ~ ~ ~ \textsf{debranch}(c, n, \ell) ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu' \]

A command given some store \emph{mu}, and evaluation level \emph{pc} produces a store \emph{\(\mu\)'} in time \emph{T}.
\end{block}
\end{frame}
\begin{frame}[label={sec:org4047210}]{Dynamic IFC}
Let us imagine there are variables \emph{x} and \emph{y}, where \emph{x} holds some sensitive data and \emph{y} does not. There are 3 kinds of leaks that could happen. \pause
\begin{example}[Direct Flow]\label{sec:orgf1ef42a}
\(x:=y\)
\pause
\end{example}
\begin{example}[Indirect Flow]\label{sec:orgacf133a}
\(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~y:=1\)
\pause
\end{example}
\begin{example}[Side Channel]\label{sec:orgc8ea6e1}
\(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~\{y:=1; ~y:=1\}\)
\end{example}
\end{frame}
\begin{frame}[label={sec:org1d7001b}]{Threat Model}
Thus, given an adversary that can execute the program under security label \(\ell\). \pause
\begin{block}{Data Security}
The adversary can view the state of the memory, but values that are high relative to \(\ell\) are invisible. \pause
As an example, let us take \(L \sqsubseteq M \sqsubseteq H\) and let us take \(\ell = M\).

Let us say our \emph{\(\mu\)} is \emph{x \(\rightarrow\) true\textsuperscript{L}, y \(\rightarrow\) true\textsuperscript{M}, z \(\rightarrow\) true\textsuperscript{H}}, then the adversary's view of the memory is: \pause

\emph{x \(\rightarrow\) true\textsuperscript{L}, y \(\rightarrow\) true\textsuperscript{M}, z \(\rightarrow\) *}
\pause
\end{block}
\begin{block}{Timing Security}
The adversary has exact knowledge of when and where each memory access takes place during a program's execution.
\end{block}
\end{frame}
\begin{frame}[label={sec:orgb6a054d}]{Expression Semantics}
\begin{center}
\includegraphics[width=.9\linewidth]{./expr.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:org3ccf4b9}]{Command Semantics}
\begin{block}{The Basics}
\begin{center}
\includegraphics[width=.9\linewidth]{./basics_c.png}
\end{center}
\pause
\end{block}
\begin{block}{IF-HIGH}
\begin{center}
\includegraphics[width=.9\linewidth]{./ifhigh_c.png}
\end{center}
\end{block}
\end{frame}
\begin{frame}[label={sec:orgb4e6936}]{Debranch Semantics: The Basics}
\begin{center}
\includegraphics[width=.9\linewidth]{./basics_d.png}
\end{center} 
\end{frame}
\begin{frame}[label={sec:org2b2224d}]{Debranch Semantics: IFs}
\begin{center}
\includegraphics[width=.9\linewidth]{./ifs.png}
\end{center}
\end{frame}
\section{(Formal) Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks}
\label{sec:orge2e971a}
\begin{frame}[label={sec:org1e819cf}]{Rocq, Rocq, Correct!}
We choose to prove our theorems and formalise our semantics within the \alert{Rocq} (formerly Coq) theorem prover.
\end{frame}
\begin{frame}[label={sec:org130ca38}]{PartialOrder}
\begin{center}
\includegraphics[width=.9\linewidth]{./partial_order.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orga714e9e}]{Join Semi-Lattice}
\begin{center}
\includegraphics[width=.9\linewidth]{./join.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgc776372}]{Observational Equivalence}
\end{frame}
\begin{frame}[label={sec:org91d9b32}]{Timing Sensitive Non-Interference}
\end{frame}
\begin{frame}[label={sec:orgcd8a4ca}]{Threat Model, Revisited}
\end{frame}
\end{document}
