% Created 2025-12-16 Tue 15:36
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usetheme{Madrid}
\author{Aniket Mishra, Abhishek Bichhawat}
\date{\textit{{[}2025-12-18 Thu]}}
\title{Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks}
\hypersetup{
 pdfauthor={Aniket Mishra, Abhishek Bichhawat},
 pdftitle={Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks},
 pdfkeywords={beamer org orgmode},
 pdfsubject={Example of using org to create presentations using the beamer exporter},
 pdfcreator={Emacs 30.2 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Timing-Based Side Channel Leaks}
\label{sec:org1fb28e6}
\begin{frame}[label={sec:org2a5830b}]{Traditional Cybersecurity}
Traditionally, cybersecurity has dealt with the analysis of \alert{overt} channels.
\begin{center}
\includegraphics[width=.9\linewidth]{./alice_bob.jpg}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgd264b44}]{What are Side Channels?}
A \emph{side} channel, on the other hand, involves no such direct access. Instead, vulnerabilities are introduced by \alert{side effects} of a program's execution.
\pause
\begin{itemize}
\item Power used during the program's execution
\end{itemize}
\pause
\begin{itemize}
\item Sound generated by the machine running the program
\end{itemize}
\pause
\begin{itemize}
\item \alert{Time it takes for the program to execute}
\end{itemize}
\end{frame}
\begin{frame}[label={sec:orgb7933ce},fragile]{An Illustrative Example}
 Let us consider a C program that checks some input against a given password by comparing it by character by character.
\begin{verbatim}
bool matchpwd ( int * input , size_t n ) {
  if ( n != pwd_length ) return false;
  for ( int i = 0; i < n ; i ++) {
    if ( input [ i ] != pwd [ i ]) return false ;
  }
  return true ;
}
\end{verbatim}
\end{frame}
\begin{frame}[label={sec:org837623b}]{An Exploit}
Let's say the password is \alert{101010}, an exploit may look like the following.
\begin{example}[An Attack Trace]\label{sec:org1fbba7a}
000000 \dotfill Rejected in 1\textsuperscript{st} iteration \pause \\
\alert{10}0000 \dotfill Rejected in 3\textsuperscript{rd} iteration \pause \\
\alert{1}10000 \dotfill Rejected in 2\textsuperscript{nd} iteration \pause \\
\alert{1010}00 \dotfill Rejected in 5\textsuperscript{th} iteration \pause \\
\alert{101}100 \dotfill Rejected in 4\textsuperscript{th} iteration \pause \\
\alert{101010} \dotfill Password accepted!
\end{example}
\end{frame}
\begin{frame}[label={sec:org449cd93}]{The Reality of Timing Side Channels}
Speculative execution and cache side channels are subtler ways that these vulnerabilities can be introduced.
\begin{center}
\includegraphics[width=.9\linewidth]{spooky.png}
\end{center}
\end{frame}
\section{Mitigating Timing-Based Side Channel Leaks}
\label{sec:org393bc22}
\begin{frame}[label={sec:orgdd509cf}]{Dummy Code Insertion}
\begin{center}
\includegraphics[width=.9\linewidth]{./agat.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgcc40f62},fragile]{Constant Time Programming}
 \begin{block}{Constant Time Program}
\begin{verbatim}
bool equals(byte a[], size_t a_len, byte b[], size_t b_len) {
  volatile size_t x = a_len ^ b_len;
  for (size_t i = 0; ((i < a_len) & (i < b_len)); i++) {
    x |= a[i] ^ b[i];
  }
  return (x==0);
}
\end{verbatim}
\end{block}
\begin{block}{Preservation of Constant Time Property}
Separately, work has been done on ensuring the preservation of this invariant.
See: Formal verification of a constant-time preserving C compiler by Barthe et. al.   
\end{block}
\end{frame}
\begin{frame}[label={sec:org3acf89f}]{Code Generation}
\begin{block}{Program Repair}
Work has been done in linearising the source code of a program.

See: Eliminating Timing Side-Channel Leaks using Program Repair by Wu et al.
\end{block}
\begin{block}{Transforming IR}
Similarly, work has also been done at generating constant time code given a non constant-time program.

See: Constantine: Automatic Side-Channel Resistance Using Efficient Control and Data Flow Linearization by Borrello et al.
\end{block}
\end{frame}
\begin{frame}[label={sec:org174fc67}]{Our Approach}
\begin{itemize}
\item All of the above approaches require the entire \alert{source code} to be available beforehand. This is \alert{not always possible}.\pause
\item Many of these approaches employ the use of testing and fuzzing-based techniques to find sensitive execution pathways in the program. \pause
\item Thus, we propose a \alert{runtime semantics} that takes care by expanding on techniques used in \alert{dynamic Information Flow Control}. \pause Furthermore, we \alert{prove} that our semantics has the desired properties within the \alert{Rocq theorem prover}.
\end{itemize}
\end{frame}
\section{Fall-Through Semantics for Mitigating Timing-Based Side Channel leaks}
\label{sec:org491766f}
\begin{frame}[label={sec:orga345d6c}]{The WHILE Language}
\(\mu := \cdot ~\arrowvert ~ \mu, x \Rightarrow n^k\)

\pause

\(e := n ~\arrowvert ~x ~\arrowvert ~ e_1 \oplus ~e_2\)

\pause

\(c := \textsf{skip} ~\arrowvert ~x:=e  ~\arrowvert ~c_1;c_2 ~\arrowvert ~\textsf{if} ~e ~\textsf{then} ~c_1 ~\textsf{else} ~c_2 ~\arrowvert ~\textsf{while} ~e ~\textsf{do} ~c\)
\end{frame}
\begin{frame}[label={sec:orga80a180}]{Judgements}
\begin{block}{Expression Judgement}
\[e ~\arrowvert ~\mu \Downarrow_{pc} T, n^{k} \]

An expression given some store \emph{\(\mu\)} and some evaluation level \emph{pc}, evaluates to some primitive value \emph{n} along with some label \emph{k}, within time \emph{T}.
\end{block}
\begin{block}<2->{Command Judgement(s)}
\[c ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu'  ~ ~ ~ ~ ~ \textsf{debranch}(c, n, \ell) ~\arrowvert ~\mu \Downarrow_{pc} T ~\arrowvert ~\mu' \]

A command given some store \emph{mu}, and evaluation level \emph{pc} produces a store \emph{\(\mu\)'} in time \emph{T}.
\end{block}
\end{frame}
\begin{frame}[label={sec:org73aa06c}]{Dynamic IFC}
Let us imagine there are variables \emph{x} and \emph{y}, where \emph{x} is hidden and holds some sensitive data and \emph{y} does not. There are 3 kinds of leaks that could happen. \pause
\begin{example}[Direct Flow]\label{sec:orgf686839}
\(y:=x\)
\pause
\end{example}
\begin{example}[Indirect Flow]\label{sec:orgdf11b73}
\(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~y:=1\)
\pause
\end{example}
\begin{example}[Side Channel]\label{sec:orgef809bd}
\(\textsf{if} ~x ~\textsf{then} ~y:=0 ~\textsf{else} ~\{y:=1; ~y:=1\}\)
\end{example}
\end{frame}
\begin{frame}[label={sec:org8531894}]{Threat Model}
Thus, given an adversary that can execute the program under security label \(\ell\). \pause
\begin{block}{Data Security}
The adversary can view the state of the memory, but values that are high relative to \(\ell\) are invisible. \pause
As an example, let us take \(L \sqsubseteq M \sqsubseteq H\) and let us take \(\ell = M\).

Let us say our \emph{\(\mu\)} is \emph{x \(\rightarrow\) true\textsuperscript{L}, y \(\rightarrow\) true\textsuperscript{M}, z \(\rightarrow\) true\textsuperscript{H}}, then the adversary's view of the memory is: \pause

\emph{x \(\rightarrow\) true\textsuperscript{L}, y \(\rightarrow\) true\textsuperscript{M}, z \(\rightarrow\) *}
\pause
\end{block}
\begin{block}{Timing Security}
The adversary has exact knowledge of when and where each memory access takes place during a program's execution.
\end{block}
\end{frame}
\begin{frame}[label={sec:org089a1fe}]{Expression Semantics}
\begin{center}
\includegraphics[width=.9\linewidth]{./expr.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:org1008753}]{Command Semantics}
\begin{block}{The Basics}
\begin{center}
\includegraphics[width=.9\linewidth]{./basics_c.png}
\end{center}
\pause
\end{block}
\begin{block}{IF-HIGH}
\begin{center}
\includegraphics[width=.9\linewidth]{./ifhigh_c.png}
\end{center}
\end{block}
\end{frame}
\begin{frame}[label={sec:org526263e}]{Debranch Semantics: The Basics}
\begin{center}
\includegraphics[width=.9\linewidth]{./basics_d.png}
\end{center} 
\end{frame}
\begin{frame}[label={sec:orge30d63b}]{Debranch Semantics: IFs}
\begin{center}
\includegraphics[width=.9\linewidth]{./ifs.png}
\end{center}
\end{frame}
\section{(Formal) Fall-Through Semantics for Mitigating Timing-Based Side Channel Leaks}
\label{sec:org26cb65c}
\begin{frame}[label={sec:org002f386}]{Rocq, Rocq, Correct!}
We choose to prove our theorems and formalise our semantics within the \alert{Rocq} (formerly Coq) theorem prover.
\end{frame}
\begin{frame}[label={sec:org850f7da}]{PartialOrder}
\begin{center}
\includegraphics[width=.9\linewidth]{./partial_order.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:org7cad8d4}]{Join Semi-Lattice}
\begin{center}
\includegraphics[width=.9\linewidth]{./join.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgc230a95}]{Expressing Grammars}
\begin{center}
\includegraphics[width=.9\linewidth]{./grammar.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgfeb3c8a}]{Expressing Semantics}
\begin{center}
\includegraphics[width=.9\linewidth]{./semantics.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orge7a11e1}]{Expressing Invariants}
\begin{center}
\includegraphics[width=.9\linewidth]{./invariant.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgff00bd8}]{Observational Equivalence}
\begin{center}
\includegraphics[width=.9\linewidth]{./obseq.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgebafb39}]{Timing Sensitive Non-Interference}
\begin{center}
\includegraphics[width=.9\linewidth]{./timsec.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:org42c8abd}]{Soundness}
\begin{center}
\includegraphics[width=.9\linewidth]{./sound.png}
\end{center}
\end{frame}
\begin{frame}[label={sec:orgb5cb718}]{Partial Completeness}
\begin{center}
\includegraphics[width=.9\linewidth]{./pcomplete.png}
\end{center}
\end{frame}
\end{document}
